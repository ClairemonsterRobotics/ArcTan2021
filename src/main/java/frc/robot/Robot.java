// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package frc.robot;

import edu.wpi.first.hal.FRCNetComm.tInstances;
import edu.wpi.first.hal.FRCNetComm.tResourceType;
import edu.wpi.first.hal.HAL;
import edu.wpi.first.wpilibj.TimedRobot;
import edu.wpi.first.wpilibj.command.Command;
import edu.wpi.first.wpilibj.command.Scheduler;
import edu.wpi.first.wpilibj.livewindow.LiveWindow;
import edu.wpi.first.wpilibj.smartdashboard.SendableChooser;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import frc.robot.commands.*;
import frc.robot.subsystems.*;
import edu.wpi.first.wpilibj.DriverStation;



import com.ctre.phoenix.motorcontrol.Faults;
import com.ctre.phoenix.motorcontrol.InvertType;
import com.ctre.phoenix.motorcontrol.TalonFXInvertType;
import com.ctre.phoenix.motorcontrol.can.WPI_TalonFX;


import edu.wpi.first.wpilibj.Joystick;
import edu.wpi.first.wpilibj.TimedRobot;
import edu.wpi.first.wpilibj.drive.DifferentialDrive;


/**
 * The VM is configured to automatically run this class, and to call the
 * functions corresponding to each mode, as described in the TimedRobot
 * documentation. If you change the name of this class or the package after
 * creating this project, you must also update the build.properties file in the
 * project.
 */
public class Robot extends TimedRobot {

    Command autonomousCommand;
    SendableChooser<Command> chooser = new SendableChooser<>();

    public static OI oi;

    public static double shootRunning;
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    public static driveSub driveSub;
    public static shootSub shootSub;
    public static lowererSub lowererSub;
    public static intakeSub intakeSub;
    public static climbSub climbSub;
    public static gyroSub gyroSub;
    public static spinSub spinSub;
    public static conveyorSub conveyorSub;

    public static boolean InitTimerPassed = false;
    public static boolean executeIsAtSetpoint = false;
    public static boolean InEnd = false;
    public static boolean CancelFailed = false;

    private String gameData;
    public static String targetColor;

     /*
     * --- [1] Update CAN Device IDs ------
     */
    public static WPI_TalonFX _rghtFront = new WPI_TalonFX(5),
                              _rghtFollower = new WPI_TalonFX(4),
                              _leftFront = new WPI_TalonFX(0),
                              _leftFollower = new WPI_TalonFX(1);

    DifferentialDrive _diffDrive = new DifferentialDrive(_leftFront, _rghtFront);

    Joystick _joystick = new Joystick(0);

    Faults _faults_L = new Faults();
    Faults _faults_R = new Faults();


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    /**
     * This function is run when the robot is first started up and should be used
     * for any initialization code.
     */
    @Override
    public void robotInit() {

          /* factory default values */
          _rghtFront.configFactoryDefault();
          _rghtFollower.configFactoryDefault();
          _leftFront.configFactoryDefault();
          _leftFollower.configFactoryDefault();
  
          /* set up followers */
          _rghtFollower.follow(_rghtFront);
          _leftFollower.follow(_leftFront);
  
          /* [3] flip values so robot moves forward when stick-forward/LEDs-green */
          _rghtFront.setInverted(TalonFXInvertType.Clockwise); // !< Update this
          _leftFront.setInverted(TalonFXInvertType.CounterClockwise); // !< Update this
  
          /*
           * set the invert of the followers to match their respective master controllers
           */
          _rghtFollower.setInverted(InvertType.FollowMaster);
          _leftFollower.setInverted(InvertType.FollowMaster);
          /*
           * Talon FX does not need sensor phase set for its integrated sensor
           * This is because it will always be correct if the selected feedback device is integrated sensor (default value)
           * and the user calls getSelectedSensor* to get the sensor's position/velocity.
           * 
           * https://phoenix-documentation.readthedocs.io/en/latest/ch14_MCSensor.html#sensor-phase
           */
          // _rghtFront.setSensorPhase(true);
          // _leftFront.setSensorPhase(true);
  
          /*
           * WPI drivetrain classes defaultly assume left and right are opposite. call
           * this so we can apply + to both sides when moving forward. DO NOT CHANGE
           */
          _diffDrive.setRightSideInverted(false);
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
        driveSub = new driveSub();
        shootSub = new shootSub();
        lowererSub = new lowererSub();
        intakeSub = new intakeSub();
        climbSub = new climbSub();
        gyroSub = new gyroSub();
        spinSub = new spinSub();
        conveyorSub = new conveyorSub();

        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
        // OI must be constructed after subsystems. If the OI creates Commands
        // (which it very likely will), subsystems are not guaranteed to be
        // constructed yet. Thus, their requires() statements may grab null
        // pointers. Bad news. Don't move it.
        oi = new OI();

        HAL.report(tResourceType.kResourceType_Framework, tInstances.kFramework_RobotBuilder);

        // Add commands to Autonomous Sendable Chooser
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=AUTONOMOUS

        chooser.setDefaultOption("Autonomous Command", new Autonomous(0));

        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=AUTONOMOUS
        SmartDashboard.putData("Auto mode", chooser);

        SmartDashboard.putBoolean("executeIsAtSetpoint", Robot.executeIsAtSetpoint);

        
    }

    /**
     * This function is called when the disabled button is hit. You can use it to
     * reset subsystems before shutting down.
     */
    @Override
    public void disabledInit() {

    }

    @Override
    public void disabledPeriodic() {
        Scheduler.getInstance().run();
    }

    @Override
    public void autonomousInit() {
        autonomousCommand = chooser.getSelected();
        // schedule the autonomous command (example)
        if (autonomousCommand != null)
            autonomousCommand.start();
    }

    /**
     * This function is called periodically during autonomous
     */
    @Override
    public void autonomousPeriodic() {
        Scheduler.getInstance().run();
    }

    @Override
    public void teleopInit() {
        shootRunning = 1;
        // This makes sure that the autonomous stops running when
        // teleop starts running. If you want the autonomous to
        // continue until interrupted by another command, remove
        // this line or comment it out.
        if (autonomousCommand != null)
            autonomousCommand.cancel();
    }

    /**
     * This function is called periodically during operator control
     */
    @Override
    public void teleopPeriodic() {
        Scheduler.getInstance().run();

        String work = "";

        /* get gamepad stick values */
        double forw = +1 * _joystick.getRawAxis(4); /* positive is forward */
        double turn = -1 * _joystick.getRawAxis(1); /* positive is right */
        boolean btn1 = _joystick.getRawButton(1); /* is button is down, print joystick values */

        /* deadband gamepad 10% */
        if (Math.abs(forw) < 0.10) {
            forw = 0;
        }
        if (Math.abs(turn) < 0.10) {
            turn = 0;
        }

        /* drive robot */
        _diffDrive.arcadeDrive(forw, turn);

        /*
         * [2] Make sure Gamepad Forward is positive for FORWARD, and GZ is positive for
         * RIGHT
         */
        work += " GF:" + forw + " GT:" + turn;

        /* get sensor values */
        // double leftPos = _leftFront.GetSelectedSensorPosition(0);
        // double rghtPos = _rghtFront.GetSelectedSensorPosition(0);
        double leftVelUnitsPer100ms = _leftFront.getSelectedSensorVelocity(0);
        double rghtVelUnitsPer100ms = _rghtFront.getSelectedSensorVelocity(0);

        work += " L:" + leftVelUnitsPer100ms + " R:" + rghtVelUnitsPer100ms;

        /*
         * drive motor at least 25%, Talons will auto-detect if sensor is out of phase
         */
        _leftFront.getFaults(_faults_L);
        _rghtFront.getFaults(_faults_R);

        if (_faults_L.SensorOutOfPhase) {
            work += " L sensor is out of phase";
        }
        if (_faults_R.SensorOutOfPhase) {
            work += " R sensor is out of phase";
        }

        /* print to console if btn1 is held down */
        if (btn1) {
            System.out.println(work);
        }


        SmartDashboard.putNumber("right front position", _rghtFront.getSelectedSensorPosition(0));
        SmartDashboard.putNumber("right follower position", _rghtFollower.getSelectedSensorPosition(0));
        SmartDashboard.putNumber("left front position", _leftFront.getSelectedSensorPosition(0));
        SmartDashboard.putNumber("left follower position", _leftFollower.getSelectedSensorPosition(0));
    }
}