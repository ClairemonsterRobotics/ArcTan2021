// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package frc.robot.commands;

import edu.wpi.first.wpilibj.command.Command;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import frc.robot.Robot;
import com.revrobotics.ColorMatch;
import com.revrobotics.ColorMatchResult;
import com.revrobotics.ColorSensorV3;
import edu.wpi.first.wpilibj.I2C;
//import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import edu.wpi.first.wpilibj.util.Color;
import edu.wpi.first.wpilibj.DriverStation;

/**
 *
 */
public class spinWheel extends Command {

    public int spinCount = 0;
    public int encoderClicks = 2048;
    public int clicksPerWheelSpin = 8 * encoderClicks; //change to 8.29 if no workey
    public int clicksPerSect = encoderClicks; //might need to be adjusted if no workey
    boolean isWheelSpinning = false;
    public int desiredPos = 3 * clicksPerWheelSpin;
    public int sectionOffset = 0;
    public int desiredPos2 = 2000;

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_DECLARATIONS
    //private int m_Operation;
    private String targetColor;
    int Condition;

    String gameData;

    private final I2C.Port i2cPort = I2C.Port.kOnboard;
    private final ColorSensorV3 colorSensor = new ColorSensorV3(i2cPort);
    private final ColorMatch colorMatcher = new ColorMatch();

    private final Color blueTarget = ColorMatch.makeColor(.22, .45, .30);
    private final Color redTarget = ColorMatch.makeColor(.46, .37, .16);
    private final Color yellowTarget = ColorMatch.makeColor(.32, .49, .17);
    private final Color greenTarget = ColorMatch.makeColor(.22, .51, .25);

    public double spinInitSensorValue;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_DECLARATIONS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR
    public spinWheel(int Condition) {

        this.Condition = Condition;

        this.targetColor = Robot.targetColor;
        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_SETTING

        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_SETTING
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES

        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
        requires(Robot.spinSub);
    }

    public spinWheel() {

    }

    // Called just before this Command runs the first time
    @Override
    protected void initialize() {
        isWheelSpinning = false;
        spinInitSensorValue = Robot.spinSub.checkEncoders();
        Robot.spinSub.sendInitSensorValue(spinInitSensorValue);

    }

    // Called repeatedly when this Command is scheduled to run
    @Override
    protected void execute() {
      SmartDashboard.putString("is execute working", "it is working");

        colorMatcher.addColorMatch(blueTarget);
        colorMatcher.addColorMatch(redTarget);
        colorMatcher.addColorMatch(yellowTarget);
        colorMatcher.addColorMatch(greenTarget);

        Color detectedColor = colorSensor.getColor();
        //SmartDashboard.putString("execute", "Execute");
        //SmartDashboard.putNumber("red value", detectedColor.red);
        //SmartDashboard.putNumber("green value", detectedColor.green);
        //SmartDashboard.putNumber("blue value", detectedColor.blue);

        ColorMatchResult match = colorMatcher.matchClosestColor(detectedColor);
        String readableColor = match.color.toString();
        SmartDashboard.putString("readable color value", readableColor);

        if (Condition == 1) {
            //Code for spinning the wheel 3 times using the encoder
            SmartDashboard.putString("is condition 1 working", "yes");
            Robot.spinSub.goToPos(desiredPos, "3 times around");
            SmartDashboard.putNumber("Position after 3xSpin", Robot.spinSub.checkEncoders());
            cancel();
            //end();

        } else if (Condition == 2) {
            gameData = DriverStation.getInstance().getGameSpecificMessage();
            if (gameData.length() > 0) {
                targetColor = gameData;
                switch (targetColor.charAt(0)) {
                case 'B': {
                    // Blue case code
                    if (readableColor.equals("edu.wpi.first.wpilibj.util.ColorShim@b924ac5f")) {//red
                        sectionOffset = 2;
                        SmartDashboard.putNumber("offset red for blue", sectionOffset);
                    } else if (readableColor.equals("edu.wpi.first.wpilibj.util.ColorShim@795c8a5f")) {//green
                        sectionOffset = 1;
                        SmartDashboard.putNumber("offset green for blue", sectionOffset);
                    } else if (readableColor.equals("edu.wpi.first.wpilibj.util.ColorShim@9877d45f")) {//yellow
                        sectionOffset = 3;
                        SmartDashboard.putNumber("offset yellow for blue", sectionOffset);
                    }
                }
                    break;
                case 'G': {
                  // Green case code
                    if (readableColor.equals("edu.wpi.first.wpilibj.util.ColorShim@b924ac5f")) {//red
                        sectionOffset = 1;
                        SmartDashboard.putNumber("offset red for green", sectionOffset);
                    } else if (readableColor.equals("edu.wpi.first.wpilibj.util.ColorShim@78f2845f")) {//blue
                        sectionOffset = 3;
                        SmartDashboard.putNumber("offset blue for green", sectionOffset);
                    } else if (readableColor.equals("edu.wpi.first.wpilibj.util.ColorShim@9877d45f")) {//yellow
                        sectionOffset = 2;
                        SmartDashboard.putNumber("offset yellow for green", sectionOffset);
                    }
                }
                    break;
                case 'R': {
                  // Red case code
                    if (readableColor.equals("edu.wpi.first.wpilibj.util.ColorShim@78f2845f")) {//blue
                        sectionOffset = 2;
                        SmartDashboard.putNumber("offset blue for red", sectionOffset);
                    } else if (readableColor.equals("edu.wpi.first.wpilibj.util.ColorShim@795c8a5f")) {//green
                        sectionOffset = 3;
                        SmartDashboard.putNumber("offset green for red", sectionOffset);
                    } else if (readableColor.equals("edu.wpi.first.wpilibj.util.ColorShim@9877d45f")) {//yellow
                        sectionOffset = 1;
                        SmartDashboard.putNumber("offset yellow for red", sectionOffset);
                    }
                }
                    break;
                case 'Y': {
                  // Yellow case code
                    if (readableColor.equals("edu.wpi.first.wpilibj.util.ColorShim@b924ac5f")) {//red
                        sectionOffset = 3;
                        SmartDashboard.putNumber("offset red for yellow", sectionOffset);
                    } else if (readableColor.equals("edu.wpi.first.wpilibj.util.ColorShim@795c8a5f")) {//green
                        sectionOffset = 2;
                        SmartDashboard.putNumber("offset green for yellow", sectionOffset);
                    } else if (readableColor.equals("edu.wpi.first.wpilibj.util.ColorShim@78f2845f")) {//blue
                        sectionOffset = 1;
                        SmartDashboard.putNumber("offset blue for yellow", sectionOffset);
                    }
                }
                    break; 
                    default :
                    // This is corrupt data
                    break;
                }
            }
            desiredPos = desiredPos + sectionOffset * clicksPerSect;
            Robot.spinSub.goToPos(desiredPos, "Based on color sensor");

        } else { //Condition 3
           Robot.spinSub.beginSpin();
           Robot.spinSub.checkEncoders();

        }
    }

    // Make this return true when this Command no longer needs to run execute()
    @Override
    protected boolean isFinished() {
        return false;
    }

    // Called once after isFinished returns true
    @Override
    protected void end() {
        cancel();
    }

    // Called when another command which requires one or more of the same
    // subsystems is scheduled to run
    @Override
    protected void interrupted() {
        end();
    }

    @Override
    public synchronized void cancel() {
        if (Condition == 3){
            Robot.spinSub.stopSpin();
        }
        super.cancel();
    }
}
