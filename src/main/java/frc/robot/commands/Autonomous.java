// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package frc.robot.commands;

import com.ctre.phoenix.motorcontrol.TalonFXControlMode;

import edu.wpi.first.wpilibj.command.Command;
import frc.robot.Robot;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

/**
 *
 */
public class Autonomous extends Command {

    private abstract class Instruction{
        protected String type;
        protected char direction;
        protected double distance, //distance to travel. for turning, this will be the distance of the outer wheel
                        velocity, 
                        steepness, //for turning. value is from 0 to 1. high steepness = very steep turn, and vice versa
                        targetPosition; //distance to travel, relative to position began at. outer wheel for turning as well
        public abstract void execute();
        public abstract boolean hasFinished(double lPos, double rPos);
        public String getType() {
            return this.type;
        }
        public double getDistance() {
            return this.distance;
        }
        public char getDirection() {
            return this.direction;
        }
    }

    private class Advance extends Instruction{
        public Advance(double distance, double velocity){
            this.type = "advance";
            this.distance = distance;
            this.velocity = velocity;
        }

        public void execute(){
            Robot.driveSub.driveStraight(this.velocity);
        }

        public boolean hasFinished(double lPos, double rPos){
            return (lPos+rPos)/2 > this.targetPosition;
        }
    }

    private class Turn extends Instruction{
        public Turn(char direction, double distance, double velocity, double steepness){
            this.type = "turn";
            this.direction = direction;
            this.distance = distance;
            this.velocity = velocity;
            this.steepness = steepness;
        }

        public void execute(){
            //outer wheel must turn faster than inner wheel. if turning right, left (outer) wheel must turn faster.
            double speedL = this.direction == 'R' ? this.velocity*(1-this.steepness) : this.velocity, 
                    speedR = this.direction == 'L' ? this.velocity*(1-this.steepness) : this.velocity;
            Robot.driveSub.turn(this.direction, speedL, speedR);
        }

        public boolean hasFinished(double lPos, double rPos){
            return this.direction == 'L' ? rPos > this.targetPosition : lPos > this.targetPosition;
        }
    }

    private Instruction[] instructions = {
        new Advance(10, 10),
        new Turn('L', 10, 10, 0.7),
        new Advance(10, 10),
        new Advance(10, 10),
        new Advance(10, 10),
    };

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_DECLARATIONS
    static double degToRad = Math.PI/180.0;
    final double distancePerPulse = 6*Math.PI/360;

    int curStage = 0;
    private double rPos=0, lPos=0;
    private int m_Position;
 
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_DECLARATIONS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR
    public Autonomous(int Position) {

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_SETTING
        this.m_Position = Position;

        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_SETTING
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
    }
    
    // Called just before this Command runs the first time
    @Override
    protected void initialize() {
        createTargetPosition(instructions[0]);
    }

    @Override
    protected void execute(){
        rPos = Robot._rghtFront.getSelectedSensorPosition(0);
        lPos = Robot._leftFront.getSelectedSensorPosition(0);

        Instruction instruction = instructions[curStage];
        instruction.execute();

        //create the next target position after current target position is reached (instruction has finished)
        if(instruction.hasFinished(lPos, rPos) && ++curStage<instructions.length){
            createTargetPosition(instructions[curStage]);
        }

        SmartDashboard.putNumber("right front position", Robot._rghtFront.getSelectedSensorPosition(0));
        SmartDashboard.putNumber("right follower position", Robot._rghtFollower.getSelectedSensorPosition(0));
        SmartDashboard.putNumber("left front position", Robot._leftFront.getSelectedSensorPosition(0));
        SmartDashboard.putNumber("left follower position", Robot._leftFollower.getSelectedSensorPosition(0));
    }

    //set target position to current position + target distance if going straight
    //set target position to left (outer) wheel distance + desired distance if turning right, vice versa for turning left
    private void createTargetPosition(Instruction instruction){
        instruction.targetPosition = 
                    instruction.getType().equals("advance") 
                    ? 
                    instruction.getDistance() + (lPos+rPos)/2 : instruction.getDirection() == 'R' 
                    ? 
                    instruction.getDistance() + lPos : instruction.getDistance() + rPos;
    }

    // Make this return true when this Command no longer needs to run execute()
    @Override
    protected boolean isFinished() {
        return curStage >= instructions.length;
    }

    // Called once after isFinished returns true
    @Override
    protected void end() {
    }

    // Called when another command which requires one or more of the same
    // subsystems is scheduled to run
    @Override
    protected void interrupted() {
    }
}
