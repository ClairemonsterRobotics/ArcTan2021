// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package frc.robot.commands;

import com.ctre.phoenix.motorcontrol.TalonFXControlMode;

import edu.wpi.first.wpilibj.command.Command;
import frc.robot.Robot;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

/**
 *
 */
public class Autonomous extends Command {

    private class Instruction{
        private String type; //advance = go straight, turn = turn
        private char direction; //R or L - for turning
        private double distance, //distance to travel. for turning, this will be the distance of the outer wheel
                       velocity, 
                       steepness, //for turning. value is from 0 to 1. high steepness = very steep turn, and vice versa
                       targetPosition; //distance to travel, relative to position began at. outer wheel for turning as well

        public Instruction(String type, double distance, double velocity){
            this.type = type;
            this.distance = distance;
            this.velocity = velocity;
        }

        public Instruction(String type, char direction, double distance, double velocity, double steepness){
            this.type = type;
            this.direction = direction;
            this.distance = distance;
            this.velocity = velocity;
        }

        public void execute(){
            if(type.equals("advance")){//going straight
                Robot.driveSub.driveStraight(velocity);
            }else{//turning
                //outer wheel must turn faster than inner wheel. if turning right, left (outer) wheel must turn faster.
                double speedL = direction == 'R' ? velocity*(1-steepness) : velocity, 
                       speedR = direction == 'L' ? velocity*(1-steepness) : velocity;
                Robot.driveSub.turn(direction, speedL, speedR);
            }
        }

        public boolean hasFinished(double lPos, double rPos){
            if(type.equals("advance"))//moving forward - get average distance of two sides
                return (lPos+rPos)/2 > targetPosition;
            else//turning - get distance of the outer sides
                return direction == 'L' ? rPos>targetPosition : lPos>targetPosition;
        }
    }

    private Instruction[] instructions = {
        new Instruction("advance", 5, 5),
        new Instruction("turn", 'L', 5, 5, 0.8),
        new Instruction("advance", 5, 5),
        new Instruction("advance", 5, 5),
        new Instruction("advance", 5, 5),
    };

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_DECLARATIONS
    static double degToRad = Math.PI/180.0;
    final double distancePerPulse = 6*Math.PI/360;

    int curStage = 0;
    private double rPos=0, lPos=0;
    private int m_Position;
 
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_DECLARATIONS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR
    public Autonomous(int Position) {

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_SETTING
        this.m_Position = Position;

        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_SETTING
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
    }
    
    // Called just before this Command runs the first time
    @Override
    protected void initialize() {
    }

    @Override
    protected void execute(){
        rPos = Robot._rghtFront.getSelectedSensorPosition(0);
        lPos = Robot._leftFront.getSelectedSensorPosition(0);

        Instruction instruction = instructions[curStage];
        instruction.execute();
        if(instruction.hasFinished(lPos, rPos) && curStage<instructions.length){
            //move on to next instruction
            instruction = instructions[++curStage];

            //set target position to current position + target distance if going straight
            //set target position to left (outer) wheel distance + desired distance if turning right, vice versa for turning left
            instruction.targetPosition = 
                        instruction.type.equals("advance") ? instruction.distance + (lPos+rPos)/2 : 
                        instruction.direction == 'R' ? 
                        instruction.distance + lPos : instruction.distance + rPos;

        }

        SmartDashboard.putNumber("right front position", Robot._rghtFront.getSelectedSensorPosition(0));
        SmartDashboard.putNumber("right follower position", Robot._rghtFollower.getSelectedSensorPosition(0));
        SmartDashboard.putNumber("left front position", Robot._leftFront.getSelectedSensorPosition(0));
        SmartDashboard.putNumber("left follower position", Robot._leftFollower.getSelectedSensorPosition(0));
    }

    // Make this return true when this Command no longer needs to run execute()
    @Override
    protected boolean isFinished() {
        if(curStage >= instructions.length) return true;
        return false;
    }

    // Called once after isFinished returns true
    @Override
    protected void end() {
    }

    // Called when another command which requires one or more of the same
    // subsystems is scheduled to run
    @Override
    protected void interrupted() {
    }
}
