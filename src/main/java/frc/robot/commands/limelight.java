// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package frc.robot.commands;
import edu.wpi.first.wpilibj.command.Command;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import frc.robot.Robot;
import edu.wpi.first.wpilibj.Timer;
import edu.wpi.first.networktables.NetworkTable;
import edu.wpi.first.networktables.NetworkTableEntry;
import edu.wpi.first.networktables.NetworkTableInstance;
import edu.wpi.first.wpilibj.command.Command;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

/**
 *
 */
public class limelight extends Command {
    NetworkTable table = NetworkTableInstance.getDefault().getTable("limelight-orion");

    public int counter = 0;
    public double minVolts = .6;
    public double minDist = .1;
    public boolean ledOn = false;

    public boolean auto = false;

    private boolean limelightHasTarget = false;
    private double limelightDriveCommand = 0.0;
    private double limelightSteerCommand = 0.0;

    final double steerK = 0.05;                    // how hard to turn toward the target (change this value to change how far you turn towards the target)
    final double driveK = 0.5;                    // how hard to drive fwd toward the target
    final double targetArea = 2;                  // area of the target when the robot reaches the point we need it to
    final double MAX_DRIVE = .9;                   // speed limit so we don't drive too fast ;)
  
    //public float estimateDistance;

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_DECLARATIONS
 
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_DECLARATIONS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR
    public limelight() {

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_SETTING

        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_SETTING
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES

        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
    }

    // Called just before this Command runs the first time
    @Override
    protected void initialize() {
    }

    // Called repeatedly when this Command is scheduled to run
    @Override
    protected void execute() {
      Update_Limelight_Tracking(); //need this to update the tracking that we have our limelight doing

      limelightDriveCommand *= 1;
      limelightSteerCommand *= 1;

      SmartDashboard.putNumber("drive value", limelightDriveCommand);
      SmartDashboard.putNumber("steer value", limelightSteerCommand);
      SmartDashboard.putBoolean("target aquired", limelightHasTarget);

      //call the limelight drive if it sees summ
      if (limelightHasTarget)
      {
        Robot.driveSub.limelightDrive(limelightDriveCommand,limelightSteerCommand);
      }

    }

    // Make this return true when this Command no longer needs to run execute()
    @Override
    protected boolean isFinished() {
        return false;
    }

    // Called once after isFinished returns true
    @Override
    protected void end() {
      cancel();
    }

    // Called when another command which requires one or more of the same
    // subsystems is scheduled to run
    @Override
    protected void interrupted() {
      end();
    }
    
    //so this is used to make sure the robot can always move, and the movement isnt going so slow that it cant move
    public double getOutput(double slope, double var, double minDist, double minVolts, double maxVolts){
      double res = slope*var;
      if(Math.abs(res) < minVolts){ //3 is min volts
        if(Math.abs(res) < minDist){ //.1 is the 
          res = 0;
        }else{ //if tx is close enough set voltage to 0
          res = res > 0 ? minVolts : -minVolts; 
        }
      }
      if(Math.abs(res) > maxVolts) { //perventing overvoltage
        res  = res > 0 ? maxVolts : -maxVolts;
      }

      return res;
    }

    public void Update_Limelight_Tracking(){

        double tv = NetworkTableInstance.getDefault().getTable("limelight-orion").getEntry("tv").getDouble(0);
        double tx = NetworkTableInstance.getDefault().getTable("limelight-orion").getEntry("tx").getDouble(0);
        double ty = NetworkTableInstance.getDefault().getTable("limelight-orion").getEntry("ty").getDouble(0);
        double ta = NetworkTableInstance.getDefault().getTable("limelight-orion").getEntry("ta").getDouble(0);

        SmartDashboard.putNumber("tx value", tx);
        SmartDashboard.putNumber("ty value", ty);
        SmartDashboard.putNumber("tv value", tv);
        SmartDashboard.putNumber("ta value", ta);

        //just checking if the limelight sees something and sets the boolean to true or false accordingly
        if (tv < 1.0) 
        {
          limelightHasTarget = false;
          limelightDriveCommand = 0.0;
          limelightSteerCommand = 0.0;
          return;
        }else{
          limelightHasTarget = true;
        }

       // start with proportional steering
        // double steer_cmd = steerK * (tx);
        
        // if(Math.abs(steer_cmd) < minVolts){ //3 is min volts
        //   if(Math.abs(steer_cmd) < minDist){ //.1 is the 
        //     steer_cmd = 0;
        //   }else{ //if tx is close enough set voltage to 0
        //   steer_cmd = steer_cmd > 0 ? minVolts : -minVolts; 
        //   }
        // }
        // if(Math.abs(steer_cmd) > 1) { //perventing overvoltage
        //   steer_cmd  = steer_cmd > 0 ? 1 : -1;
        // }
      //limelightSteerCommand = steer_cmd;
         limelightSteerCommand = getOutput(steerK, tx, minDist, minVolts, .8);

        // limelightDriveCommand = getOutput(driveK, targetArea-ta, .1, .25, .5);

        // try to drive forward until the target area reaches our desired area
        double drive_cmd = (targetArea - ta) * driveK;

        // don't let the robot drive too fast into the goal
        if (drive_cmd > MAX_DRIVE)
        {
          drive_cmd = MAX_DRIVE;
        }else{
          drive_cmd = (targetArea - ta) *driveK;
        }
        limelightDriveCommand = drive_cmd;
  }

}