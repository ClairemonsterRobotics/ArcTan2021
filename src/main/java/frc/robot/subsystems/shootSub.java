// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package frc.robot.subsystems;

//import frc.robot.commands.*;
import edu.wpi.first.wpilibj2.command.PIDSubsystem;
import frc.robot.Robot;
import edu.wpi.first.wpilibj.livewindow.LiveWindow;
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import edu.wpi.first.wpilibj.CounterBase.EncodingType;
import edu.wpi.first.wpilibj.command.Subsystem;

import java.util.ArrayList;

import edu.wpi.first.wpilibj.Controller;
import edu.wpi.first.wpilibj.Encoder;
import edu.wpi.first.wpilibj.controller.PIDController;
import edu.wpi.first.wpilibj.controller.SimpleMotorFeedforward;
import edu.wpi.first.wpilibj.PWMTalonSRX;
import edu.wpi.first.wpilibj.PWMVictorSPX;
import edu.wpi.first.wpilibj.Spark;
import edu.wpi.first.wpilibj.SpeedController;
import edu.wpi.first.wpilibj.smartdashboard.*;

// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS

/**
 *
 */
public class shootSub extends Subsystem {

    private Encoder shootEncoderLeft;
    private PWMVictorSPX shootMotorLeft;
    private Encoder shootEncoderRight;
    private PWMVictorSPX shootMotorRight;
    // private PIDController shoot;

    public boolean atSpeed = false;

    int sampleSize = 10; // make bigge than 2

    public ArrayList<Double> rawPos = new ArrayList<Double>();
    public ArrayList<Double> rawVels = new ArrayList<Double>();
    public double currSpeed = 0.0;
    private double runningSum = 0.0;
    private double baselineReading;

    double keepSpeedConstant = .01;
    double keepSpeedBase = 2.0;

    int rampUpVoltage = 5;// volts

    SimpleMotorFeedforward shooterFeedForward;

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    // Initialize your subsystem here
    public shootSub() {
        shootEncoderLeft = new Encoder(4, 5, false, EncodingType.k1X);
        shootMotorLeft = new PWMVictorSPX(2);
        // shootEncoderRight = new Encoder(0, 1, false, EncodingType.k1X);
        shootMotorRight = new PWMVictorSPX(3);
        shooterFeedForward = new SimpleMotorFeedforward(.5, 12);
        shootEncoderLeft.setDistancePerPulse(1.0 / 40.0); // one "distance" is one full revolution, which is 1024 pulses
        shootMotorLeft.setInverted(false);
        // shootEncoderRight.setDistancePerPulse(1.0/40.0);
        shootMotorRight.setInverted(false);

        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=PID
    }

    public void enable() {

        setVoltages(rampUpVoltage);

    }

    @Override
    protected void initDefaultCommand() {
        // TODO Auto-generated method stub

    }

    public boolean atSetPoint(double desiredVelocity) {
        return currSpeed >= desiredVelocity;
    }

    // updates the value of currSpeed based on encoder values and changes the
    // voltages to keep at some speed
    public void updateSpeed() {
        double pAddition = (shootEncoderLeft.getDistance());// + shootEncoderRight.getDistance())/2; //avg encoder
                                                            // position -> one sample of position
        rawPos.add(pAddition);
        if (rawPos.size() == sampleSize) {
            rawPos.remove(0);
        }
        if (rawPos.size() >= 2) {
            double vAddition = (rawPos.get(rawPos.size() - 1) - rawPos.get(rawPos.size() - 2)); // delta position -> one
                                                                                                // sample of velocity
            rawVels.add(vAddition);
            runningSum += vAddition;
        }
        if (rawVels.size() == sampleSize) {
            runningSum -= rawVels.get(0);
            rawVels.remove(0);
        }
        if (rawVels.size() > 0)
            currSpeed = runningSum / (20.0 * rawVels.size()); // update the value of curr speed

    }

    public void keepSpeed(double desiredVelocity) {

        if (currSpeed < desiredVelocity)
            return;

        setVoltages(keepSpeedConstant * (currSpeed - desiredVelocity) + keepSpeedBase);

    }

    public void setVoltages(double val) {

        shootMotorLeft.setVoltage(val);
        shootMotorRight.setVoltage(val);

    }

    public void disable() {

        setVoltages(0);

    }

    public void runMotor(double power) {
        shootMotorLeft.set(power);
    }

    public double testVelocity() {
        //SmartDashboard.putNumber("Raw Velocity", shootEncoderLeft.getRaw());
        return shootEncoderLeft.getRate();
    }

    public void resetVelCount() {
        shootEncoderLeft.reset();
    }

}